<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ozark Pairings Builder</title>
  <style>
    :root{
      --bg:#0b0f0d; --panel:#111617; --muted:#1b2526; --accent:#8bd3dd; --accent-2:#b7e4c7;
      --text:#e7f2f3; --hint:#99a4a6; --danger:#ff6b6b; --ok:#63e6be; --gold:#f1c40f;
      --card:#0f1415; --ink:#0b0f0d; --line:#223033; --shadow:rgba(0,0,0,.35);
      --ui-scale:.8; /* 80% on-screen scale */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 10% -10%,#132022 0%,#0b0f0d 45%,#0b0f0d 100%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}

    /* Scale entire app for on-screen fit; keep print at 100% */
    .app{display:grid;grid-template-columns:320px 1fr 420px;gap:16px;height:100%;padding:16px;
      transform:scale(var(--ui-scale)); transform-origin:top left;
      width:calc(100%/var(--ui-scale)); height:calc(100%/var(--ui-scale));
    }
    @media print{
      .app{transform:none!important;width:100%!important;height:auto!important;padding:0!important}
    }

    header{grid-column:1/-1;background:linear-gradient(180deg,#0e1516,#0a0e0f);border:1px solid var(--line);border-radius:14px;padding:12px 16px;box-shadow:0 6px 20px var(--shadow);display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:20px;letter-spacing:.3px}
    .badge{padding:.2rem .5rem;border:1px solid var(--line);border-radius:999px;color:var(--accent-2);font-size:12px}

    .panel{background:linear-gradient(180deg,#101617,#0e1314);border:1px solid var(--line);border-radius:14px;box-shadow:0 10px 30px var(--shadow);overflow:hidden;display:flex;flex-direction:column;min-height:0}
    .panel .head{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid var(--line);background:#0c1111}
    .panel .head h2{font-size:14px;letter-spacing:.4px;margin:0;color:#cfe6e8;text-transform:uppercase}
    .panel .body{padding:12px;overflow:auto}

    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .row + .row{margin-top:8px}
    label{font-size:12px;color:var(--hint)}
    input[type="text"], input[type="number"], select{background:#0e1415;border:1px solid var(--line);color:var(--text);padding:8px 10px;border-radius:10px;outline:none}
    input:focus, select:focus{border-color:#2d4b4f;box-shadow:0 0 0 3px #2d4b4f44}
    .btn{background:#132325;border:1px solid #234246;color:var(--text);padding:8px 12px;border-radius:12px;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
    .btn.primary{background:#17393d;border-color:#2a6f77;color:#c9fbff}
    .btn.warn{background:#3d1717;border-color:#772a2a;color:#ffd6d6}

    .pool{display:flex;flex-direction:column;gap:10px}
    .pool-controls{display:flex;gap:8px;flex-wrap:wrap}
    .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#101717;color:#bfe7ea;font-size:12px;cursor:pointer;user-select:none}
    .pill.active{background:#17393d;border-color:#2a6f77;color:#dcffff}
    .players{display:grid;grid-template-columns:1fr;gap:6px;min-height:80px}
    .player{display:flex;align-items:center;gap:8px;background:var(--card);border:1px solid var(--line);padding:8px;border-radius:12px;cursor:grab}
    .player:active{cursor:grabbing}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.ozark{background:#2ecc71}
    .dot.valley{background:#3498db}
    .meta{font-size:12px;color:#a7b1b2}

    .builder-controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:8px}
    .tabs{display:flex;gap:6px}
    .tabs.segment{background:#0e1415;padding:4px;border:1px solid var(--line);border-radius:999px}
    .tab{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#0f1617;color:#bfe7ea;font-size:12px;cursor:pointer}
    .tab.active{background:#17393d;border-color:#2a6f77;color:#dcffff}

    .grid{display:grid;grid-template-columns:repeat(2, minmax(280px, 1fr));gap:10px}
    .card{background:#0e1415;border:1px solid var(--line);border-radius:14px;padding:10px;display:flex;flex-direction:column;gap:10px;min-height:110px}
    .card h3{margin:0;font-size:14px;letter-spacing:.3px;display:flex;justify-content:space-between;align-items:center}
    .subheads{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:11px;color:#a7b1b2}
    .subheads span{padding:4px 8px;border:1px solid #223033;border-radius:8px;background:#0e1415;text-align:center}
    .slots{display:grid;gap:6px}
    .slots.team{grid-template-columns:1fr 1fr}
    .slots.team .col{display:grid;grid-template-columns:1fr;gap:6px}
    .slots.singles{grid-template-columns:repeat(2,1fr)}
    .slot{background:#0b1011;border:1px dashed #2a3a3d;border-radius:10px;min-height:36px;display:flex;align-items:center;justify-content:center;padding:6px;color:#789195}
    .slot.filled{border-style:solid;border-color:#335a60;background:#0f191a;color:#d9f8fb}
    .slot.dragover{outline:2px dashed var(--accent);outline-offset:2px}

    .legend{display:flex;gap:10px;align-items:center;font-size:12px;color:#a7b1b2}
    .legend .swatch{width:10px;height:10px;border-radius:50%}

    .side .body{display:flex;flex-direction:column;gap:10px}
    .list{background:#0d1314;border:1px solid var(--line);border-radius:12px;overflow:auto}
    .list table{width:100%;border-collapse:collapse;font-size:12px}
    .list th,.list td{padding:8px;border-bottom:1px solid #1b2a2c}
    .list th{text-align:left;color:#b6cacc;position:sticky;top:0;background:#0f1516}

    @media print{
      body{background:#fff;color:#000}
      header,.panel:not(.printable){display:none}
      .printable{display:block;border:none;box-shadow:none}
    }

    body, table { font-variant-numeric: tabular-nums; }
    header { border-radius: 16px; border-top: 2px solid #2b3b3e; box-shadow: 0 12px 40px var(--shadow), inset 0 1px 0 #1a2324; }
    header h1 { letter-spacing: .08em; text-transform: uppercase; font-weight: 700; }
    header .badge { background: linear-gradient(180deg,#0f1718,#0a0e10); border-color:#2a3b3e; color:#cfe6e8; box-shadow: inset 0 0 0 1px #0a0e10, 0 6px 18px rgba(0,0,0,.35); }
    .list tbody tr:nth-child(odd){ background: linear-gradient(180deg, #0b1112, #0a0f10); }
    .list tbody tr:hover{ background:#101a1b; }
    .list td:nth-child(3), .list td:nth-child(4), .list td:nth-child(5), .list td:nth-child(6){ text-align:center; font-weight:700; }

    /* Scoreboard / results UI */
    .resultbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px}
    .rbtn{border:1px solid var(--line);background:#101718;color:#bfe7ea;padding:4px 8px;border-radius:999px;font-size:12px;cursor:pointer}
    .rbtn:hover{filter:brightness(1.08)}
    .rbtn.active{background:#17393d;border-color:#2a6f77;color:#dcffff}
    .rlabel{font-size:12px;color:#a7b1b2;margin-right:4px}
    .sep{height:1px;background:#223033;opacity:.5;margin:6px 0}
    #winnerBadge{
      background: linear-gradient(180deg,#17393d,#102526);
      border: 1px solid #2a6f77;
      padding: 6px 10px;
      border-radius: 10px;
      display: none;
      margin-top: 6px;
      font-weight: 700;
      color: #c9fbff;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Ozark Pairings Builder</h1>
      <span class="badge">Captain pairing cards & printable sheets</span>
      <div style="margin-left:auto" class="row">
        <button id="btnPrint" class="btn primary">Print / PDF</button>
        <button id="btnExport" class="btn">Export JSON</button>
        <button id="btnImportCSV" class="btn">Import CSV (players)</button>
        <button id="btnShuffle" class="btn">Shuffle All</button>
        <button id="btnResetAll" class="btn warn">Reset All</button>
      </div>
    </header>

    <!-- Player Pool -->
    <section class="panel">
      <div class="head"><h2>Player Pool</h2></div>
      <div class="body pool">
        <div class="pool-controls">
          <input id="search" type="text" placeholder="Search name or nickname" style="flex:1" />
          <div id="teamFilters" class="row"></div>
        </div>
        <div class="legend">
          <div class="swatch" style="background:#2ecc71"></div> Team Ozark
          <div class="swatch" style="background:#3498db"></div> Team Valley
        </div>
        <div id="players" class="players" aria-live="polite"></div>
        <div class="row">
          <button id="btnReloadPool" class="btn">Reload from previous site</button>
          <button id="btnAddManual" class="btn">Add player</button>
        </div>
      </div>
    </section>

    <!-- Builder -->
    <section class="panel">
      <div class="head"><h2>Builder</h2></div>
      <div class="body">
        <div class="builder-controls">
          <div class="row">
            <label>Event</label>
            <input id="eventName" type="text" placeholder="Ozark Invitational 2026" />
          </div>

          <div class="row">
            <label>Date (Day 1)</label>
            <input id="eventDate1" type="text" placeholder="2026-06-20" />
          </div>
          <div class="row">
            <label>Date (Day 2)</label>
            <input id="eventDate2" type="text" placeholder="2026-06-21" />
          </div>

          <div class="row">
            <label>Groups (both days)</label>
            <input id="numGroups" type="number" min="1" max="12" value="6" />
          </div>
        </div>

        <div class="row" style="justify-content:space-between;margin:8px 0 12px">
          <div class="row" style="gap:10px;align-items:center">
            <div class="tabs segment" id="dayTabs">
              <button class="tab active" data-day="day1">Day 1</button>
              <button class="tab" data-day="day2">Day 2</button>
            </div>
            <div class="tabs segment" id="tabs">
              <button class="tab active" data-side="front">Front 9</button>
              <button class="tab" data-side="back">Back 9</button>
            </div>
          </div>
          <div class="row">
            <label>Format</label>
            <select id="formatSelect">
              <option value="Best Ball">Best Ball (4-Ball)</option>
              <option value="Scramble">Scramble</option>
              <option value="Alt Shot">Alternate Shot</option>
              <option value="Singles">Singles Match Play</option>
            </select>
            <button id="btnClearSide" class="btn warn">Clear side</button>

            <!-- Auto-pair controls (wired in autopair.js) -->
            <label style="margin-left:10px">Auto-pair:</label>
            <button id="btnAutoPairRound" class="btn">This round</button>
            <button id="btnAutoPairDay" class="btn">Both rounds (this day)</button>
            <button id="btnAutoPairAll" class="btn">All rounds (D1 & D2)</button>

            <label class="row" style="gap:6px;margin-left:10px">
              <input id="chkFillUnassigned" type="checkbox" />
              Fill unassigned only
            </label>
          </div>
        </div>

        <div id="grid" class="grid" aria-live="polite"></div>
      </div>
    </section>

    <!-- Sidebar: Summary -->
    <aside class="panel side">
      <div class="head"><h2>Leaderboard &amp; Schedule</h2></div>
      <div class="body">
        <!-- SCOREBOARD -->
        <div id="scoreboard" class="card" style="display:flex;align-items:center;gap:14px;justify-content:space-between;flex-direction:column;align-items:stretch">
          <div style="font-weight:700">Scoreboard</div>
          <div style="display:flex;gap:16px;align-items:center;justify-content:space-between">
            <div style="display:flex;gap:6px;align-items:center">
              <span class="swatch" style="background:#2ecc71"></span>
              <span>Team Ozark:</span>
              <strong id="scoreOzark">0</strong>
            </div>
            <div style="display:flex;gap:6px;align-items:center">
              <span class="swatch" style="background:#3498db"></span>
              <span>Team Valley:</span>
              <strong id="scoreValley">0</strong>
            </div>
          </div>
          <div id="winnerBadge"></div>
        </div>

        <div class="row" style="margin-top:8px">
          <div class="pill" id="pillOnce">Validate: each player used once per side</div>
          <div class="pill" id="pillBalance">Validate: team composition</div>
          <div class="pill" id="pillAutoBalance">Auto-Balance (teams)</div>
          <div class="pill" id="pillAutoHcp">Auto-Balance (HCP)</div>
        </div>

        <div id="alerts" style="margin-top:8px"></div>

        <div class="list" aria-label="Assignments table">
          <table>
            <thead>
              <tr>
                <th style="width:34%">Player</th>
                <th>Team</th>
                <th>HCP</th>
                <th>Front D1</th>
                <th>Back D1</th>
                <th>Front D2</th>
                <th>Back D2</th>
              </tr>
            </thead>
            <tbody id="assignmentTable"></tbody>
          </table>
        </div>
      </div>
    </aside>

    <!-- Print Layout -->
    <section id="printArea" class="panel printable" style="display:none;padding:16px">
      <div id="printContent"></div>
    </section>
  </div>

  <script>
    /*********************************
     *  0) DATA & STORAGE LAYER
     *********************************/
    const SIGNUPS_KEY = "ozarkSignups_v1";
    const STORAGE_KEY = "ozarkPairings_v3_twoDays";
    const TEAM_LABELS = { ozark: "Team Ozark", valley: "Team Valley" };
    const TEAM_COLORS = { ozark: "#2ecc71", valley: "#3498db" };
    const WIN_THRESHOLD = 15.5; // clinch threshold for 24-player format
    window.TEAM_FORMATS = new Set(['Best Ball','Scramble','Alt Shot','Shamble']); // expose for autopair.js

    let state = {
      players: [],
      filters: { team: "all", q: "" },
      currentDay: "day1",
      side: "front",
      eventName: "Ozark Invitational 2026",
      dates: { day1: "2026-06-20", day2: "2026-06-21" },
      format: {
        day1: { front: "Best Ball", back: "Scramble" },
        day2: { front: "Alt Shot",  back: "Singles"  }
      },
      groups: {
        day1: { front: [], back: [] },
        day2: { front: [], back: [] }
      },
      // results: team -> "ozark"/"valley"/"tie"/null; singles -> [res1,res2]
      results: {
        day1: { front: [], back: [] },
        day2: { front: [], back: [] }
      },
      numGroups: 6,
      winAnnounced: null
    };

    function uid(){ return Math.random().toString(36).slice(2,9) }
    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)) }
    function load(){ try{ const r = localStorage.getItem(STORAGE_KEY); if(r){ state = JSON.parse(r); } }catch{} }

    function sanitizeGroups() {
      if (!state.groups || typeof state.groups !== 'object') {
        state.groups = { day1: { front: [], back: [] }, day2: { front: [], back: [] } };
      }
      if (!state.groups.day1 || typeof state.groups.day1 !== 'object') state.groups.day1 = { front: [], back: [] };
      if (!state.groups.day2 || typeof state.groups.day2 !== 'object') state.groups.day2 = { front: [], back: [] };
      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          if (!Array.isArray(state.groups[day][side])) state.groups[day][side] = [];
        });
      });
      if (!state.results || typeof state.results !== 'object') {
        state.results = { day1:{front:[],back:[]}, day2:{front:[],back:[]} };
      }
    }

    // Always 4 slots per group so Singles can show two 1v1 matches
    function desiredGroupSize(fmt){ return 4; }
    window.desiredGroupSize = desiredGroupSize;

    function loadPlayersFromPreviousSite(){
      try{
        const raw = localStorage.getItem(SIGNUPS_KEY);
        if(!raw) return [];
        const arr = JSON.parse(raw);
        return (arr||[]).map((p)=>({
          id: p.id || uid(),
          firstName: p.firstName || (p.name?.split(" ")[0]||""),
          lastName: p.lastName || (p.name?.split(" ").slice(1).join(" ")||""),
          nickname: p.nickname || "",
          team: (p.team||"").toLowerCase().includes("valley")?"valley":"ozark",
          email: p.email||"",
          phone: p.phone||"",
          handicap: Number.isFinite(Number(p.handicap)) ? Number(p.handicap) : null
        }));
      }catch{ return [] }
    }

    function ensurePlayers(){
      if(state.players && state.players.length) return;
      const prior = loadPlayersFromPreviousSite();
      if(prior.length){ state.players = prior; return; }
      state.players = [
        {id:uid(), firstName:"Nick",   lastName:"Brown", nickname:"Frenzy",   team:"ozark",  handicap: 10.2},
        {id:uid(), firstName:"Chris",  lastName:"B.",    nickname:"CB",       team:"ozark",  handicap: 15.0},
        {id:uid(), firstName:"Alex",   lastName:"M.",    nickname:"",         team:"valley", handicap: 12.7},
        {id:uid(), firstName:"Jordan", lastName:"S.",    nickname:"J-Smooth", team:"valley", handicap: 18.4}
      ];
    }

    /* === normalizer used by merge/imports (includes handicap) === */
    function normalizePlayer(p){
      const obj = {...p};

      // names
      let first = obj.firstName || obj.First || obj.firstname || "";
      let last  = obj.lastName  || obj.Last  || obj.lastname  || "";
      if ((!first || !last) && obj.name) {
        const parts = String(obj.name).trim().split(/\s+/);
        first = first || parts[0] || "";
        last  = last  || parts.slice(1).join(" ") || "";
      }

      // nickname
      const nickname = obj.nickname || obj.Nickname || obj.nick || "";

      // team
      let teamRaw = obj.team || obj.Team || "";
      let team = "ozark";
      if (typeof teamRaw === "string" && teamRaw.toLowerCase().includes("val")) team = "valley";
      if (typeof teamRaw === "string" && teamRaw.toLowerCase().includes("oz")) team = "ozark";

      // contact
      const email = obj.email || obj.Email || "";
      const phone = obj.phone || obj.Phone || "";

      // handicap (accepts: handicap, hcp, hi, index)
      const hRaw =
        obj.handicap ?? obj.Handicap ?? obj.hcp ?? obj.HCP ?? obj.Hi ?? obj.hi ?? obj.index ?? obj.Index ?? "";
      let handicap = null;
      if (hRaw !== null && hRaw !== undefined && String(hRaw).trim() !== "") {
        const cleaned = String(hRaw).replace(/[^\d.\-]/g, "");
        const num = Number(cleaned);
        handicap = Number.isFinite(num) ? num : null;
      }

      const id = obj.id || uid();

      return {
        id,
        firstName: String(first||"").trim(),
        lastName : String(last ||"").trim(),
        nickname : String(nickname||"").trim(),
        team,
        email,
        phone,
        handicap
      };
    }

    /*********************************
     *  1) RENDER: PLAYER POOL
     *********************************/
    const elPlayers = document.getElementById('players');
    const elTeamFilters = document.getElementById('teamFilters');
    const elSearch = document.getElementById('search');

    function renderTeamFilters(){
      elTeamFilters.innerHTML = '';
      const teams = ['all','ozark','valley'];
      teams.forEach(t=>{
        const b = document.createElement('div');
        b.className = 'pill' + (state.filters.team===t?' active':'');
        b.textContent = t==='all'? 'All' : TEAM_LABELS[t];
        b.addEventListener('click',()=>{ state.filters.team = t; renderPlayers(); renderAssignmentsTable(); save(); });
        elTeamFilters.appendChild(b);
      });
    }

    function playerDisplayName(p){
      const nick = p.nickname && p.nickname.trim()?.length ? `"${p.nickname}" `:'';
      return `${p.firstName} ${nick}${p.lastName}`.replace(/\s+/g,' ').trim();
    }

    /* remove player helper (cleans from all groups + roster) */
    function removePlayerEverywhere(playerId){
      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const groups = state.groups?.[day]?.[side] || [];
          for (const g of groups) {
            for (let i=0; i<g.length; i++) {
              if (g[i] === playerId) g[i] = null;
            }
          }
        });
      });
      state.players = (state.players || []).filter(p => p.id !== playerId);
      save();
      renderAll();
    }

    function mergePlayers(existing, incoming){
      const byKey = x=> (x.firstName+'|'+x.lastName+'|'+(x.email||'')).toLowerCase();
      const map = new Map((existing||[]).map(p=>[byKey(p), p]));
      (incoming||[]).forEach(p=>{
        const np = normalizePlayer(p);
        const k = byKey(np);
        if(!map.has(k)) map.set(k,np);
      });
      return Array.from(map.values());
    }

    function renderPlayers(){
      const q = (state.filters.q||'').toLowerCase();
      const team = state.filters.team;
      elPlayers.innerHTML = '';

      const used = new Set((state.groups[state.currentDay][state.side]||[]).flat());

      (state.players || [])
        .filter(p => team==='all' || p.team===team)
        .filter(p => playerDisplayName(p).toLowerCase().includes(q))
        .sort((a,b)=> a.team.localeCompare(b.team) || playerDisplayName(a).localeCompare(playerDisplayName(b)))
        .forEach(p=>{
          const card = document.createElement('div');
          card.className = 'player';
          card.draggable = true;
          card.dataset.id = p.id;

          const hcpStr = (p.handicap!==null && p.handicap!==undefined) ? ` • HCP ${p.handicap}` : ``;

          card.innerHTML = `
            <div class="dot ${p.team}" style="background:${TEAM_COLORS[p.team]}"></div>
            <div>
              <div>${playerDisplayName(p)}</div>
              <div class="meta">${TEAM_LABELS[p.team]}${hcpStr}</div>
            </div>
            <button class="btn warn btnDel" title="Remove player"
              style="margin-left:auto;font-size:11px;line-height:1;padding:4px 8px;border-radius:8px">×</button>
          `;

          if(used.has(p.id)) card.style.opacity = .45;

          card.addEventListener('dragstart', onDragPlayer);

          const delBtn = card.querySelector('.btnDel');
          delBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            e.preventDefault();
            const name = playerDisplayName(p);
            if (confirm(`Remove ${name} from the roster and from any groups?`)) {
              removePlayerEverywhere(p.id);
            }
          });

          elPlayers.appendChild(card);
        });
    }

    elSearch.addEventListener('input', (e)=>{ state.filters.q = e.target.value; renderPlayers(); });

    document.getElementById('btnReloadPool').addEventListener('click', ()=>{
      const fromOld = loadPlayersFromPreviousSite();
      if(fromOld.length){ state.players = mergePlayers(state.players, fromOld); save(); renderAll(); alert('Loaded players from previous site signups.'); }
      else alert('No signups found under key '+SIGNUPS_KEY+'. Add players manually or use an Import button.');
    });

    document.getElementById('btnAddManual').addEventListener('click', ()=>{
      const firstName = prompt('First name?'); if(!firstName) return;
      const lastName = prompt('Last name?')||'';
      const nickname = prompt('Nickname (optional)')||'';
      const team = (prompt('Team: ozark / valley','ozark')||'ozark').toLowerCase().includes('val')?'valley':'ozark';
      const hStr = prompt('Handicap (e.g., 12.4). Leave blank if unknown:') || '';
      const hNum = Number(String(hStr).replace(/[^\d.\-]/g,''));
      const handicap = Number.isFinite(hNum) ? hNum : null;

      state.players.push({id:uid(), firstName, lastName, nickname, team, handicap});
      save(); renderAll();
    });

    /*********************************
     *  2) BUILDER GRID (Per Day + Side)
     *********************************/
    const elGrid   = document.getElementById('grid');
    const elTabs   = document.getElementById('tabs');
    const elDayTabs= document.getElementById('dayTabs');
    const elFormat = document.getElementById('formatSelect');

    function initGroupsIfNeeded(){
      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          if(!Array.isArray(state.groups[day][side])) state.groups[day][side] = [];
          if(state.groups[day][side].length !== state.numGroups){
            state.groups[day][side] = Array.from({length: state.numGroups}, (_,i)=> (state.groups[day][side][i]||[]));
          }
          const fmt = state.format[day][side];
          const gs = desiredGroupSize(fmt);
          state.groups[day][side] = state.groups[day][side].map(g=>{
            const arr = (Array.isArray(g) ? g : []).slice(0, gs);
            while (arr.length < gs) arr.push(null);
            return arr;
          });

          // --- keep results in sync with groups & format ---
          if(!state.results) state.results = {day1:{front:[],back:[]}, day2:{front:[],back:[]}};
          if(!Array.isArray(state.results[day][side])) state.results[day][side] = [];
          while(state.results[day][side].length < state.numGroups) state.results[day][side].push(null);
          state.results[day][side] = state.results[day][side].slice(0, state.numGroups);

          state.results[day][side] = state.results[day][side].map((r)=>{
            const isTeam = window.TEAM_FORMATS.has(fmt);
            if (isTeam) return (typeof r === 'string' || r===null) ? r : null;
            // singles -> [null,null] shape
            return Array.isArray(r) ? [r[0] ?? null, r[1] ?? null] : [null, null];
          });
        });
      });
    }

    function renderGrid(){
      initGroupsIfNeeded();
      elGrid.innerHTML = '';
      const day = state.currentDay;
      const side = state.side;
      const fmt = state.format[day][side];
      const isTeam = window.TEAM_FORMATS.has(fmt);

      state.groups[day][side].forEach((group, idx)=>{
        const card = document.createElement('div');
        card.className = 'card';
        const dayLabel = day==='day1' ? 'Day 1' : 'Day 2';
        card.innerHTML = `<h3>${dayLabel} • ${side==='front'?'Front 9':'Back 9'} • ${fmt}</h3>`;

        if(isTeam){
          const sub = document.createElement('div');
          sub.className = 'subheads';
          sub.innerHTML = `<span>Team A</span><span>Team B</span>`;
          card.appendChild(sub);
        }

        const slotsWrap = document.createElement('div');
        slotsWrap.className = 'slots ' + (isTeam ? 'team' : 'singles');

        if(isTeam){
          const colA = document.createElement('div'); colA.className = 'col';
          const colB = document.createElement('div'); colB.className = 'col';
          colA.appendChild(buildSlot(day, side, idx, 0, group[0]));
          colA.appendChild(buildSlot(day, side, idx, 1, group[1]));
          colB.appendChild(buildSlot(day, side, idx, 2, group[2]));
          colB.appendChild(buildSlot(day, side, idx, 3, group[3]));
          slotsWrap.appendChild(colA);
          slotsWrap.appendChild(colB);
        } else {
          // Singles = two separate 1v1 matches per group
          slotsWrap.appendChild(buildSlot(day, side, idx, 0, group[0]));
          slotsWrap.appendChild(buildSlot(day, side, idx, 1, group[1]));

          const sep = document.createElement('div');
          sep.style.gridColumn = '1 / -1';
          sep.style.height = '6px';
          sep.style.borderTop = '1px dashed #2a3a3d';
          sep.style.opacity = '0.4';
          sep.style.margin = '4px 0';
          slotsWrap.appendChild(sep);

          slotsWrap.appendChild(buildSlot(day, side, idx, 2, group[2]));
          slotsWrap.appendChild(buildSlot(day, side, idx, 3, group[3]));
        }

        card.appendChild(slotsWrap);
        card.appendChild(buildResultControls(day, side, idx, isTeam));
        elGrid.appendChild(card);
      });
      elFormat.value = fmt;
    }

    function buildSlot(day, side, groupIndex, pos, playerId){
      const s = document.createElement('div');
      s.className = 'slot'+(playerId? ' filled':'');
      s.dataset.day = day;
      s.dataset.side = side;
      s.dataset.group = groupIndex;
      s.dataset.pos = pos;

      const p = playerId ? findPlayer(playerId) : null;
      const hcp = p && (p.handicap!==null && p.handicap!==undefined) ? ` • HCP ${p.handicap}` : '';
      s.textContent = playerId ? (playerDisplayName(p) + hcp) : 'Drop player here';

      s.addEventListener('dragover', e=>{ e.preventDefault(); s.classList.add('dragover'); });
      s.addEventListener('dragleave', ()=> s.classList.remove('dragover'));
      s.addEventListener('drop', e=> onDropToSlot(e, s));
      s.addEventListener('click', ()=> {
        if(state.groups[day][side][groupIndex][pos]){
          state.groups[day][side][groupIndex][pos] = null;
          save(); renderAll();
        }
      });
      return s;
    }

    function onDragPlayer(e){
      e.dataTransfer.setData('text/player', e.currentTarget.dataset.id);
    }

    function onDropToSlot(e, slot){
      e.preventDefault(); slot.classList.remove('dragover');
      const playerId = e.dataTransfer.getData('text/player');
      if(!playerId) return;
      assignPlayerToSlot(slot.dataset.day, slot.dataset.side, Number(slot.dataset.group), Number(slot.dataset.pos), playerId);
    }

    function assignPlayerToSlot(day, side, groupIndex, pos, playerId){
      initGroupsIfNeeded();
      for(const g of state.groups[day][side]){ for(let i=0;i<g.length;i++){ if(g[i]===playerId){ g[i]=null; } } }
      state.groups[day][side][groupIndex][pos] = playerId;
      save(); renderAll();
    }

    function findPlayer(id){ return state.players.find(p=>p.id===id) }

    // Controls
    document.getElementById('eventName').addEventListener('input', e=>{ state.eventName = e.target.value; save(); });
    document.getElementById('eventDate1').addEventListener('input', e=>{ state.dates.day1 = e.target.value; save(); });
    document.getElementById('eventDate2').addEventListener('input', e=>{ state.dates.day2 = e.target.value; save(); });
    document.getElementById('numGroups').addEventListener('input', e=>{
      state.numGroups = Math.max(1, Math.min(12, Number(e.target.value)||1));
      initGroupsIfNeeded(); renderAll(); save();
    });

    elDayTabs.addEventListener('click', (e)=>{
      const t = e.target.closest('.tab'); if(!t) return;
      document.querySelectorAll('#dayTabs .tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      state.currentDay = t.dataset.day;
      save(); renderAll();
    });

    elTabs.addEventListener('click', (e)=>{
      const t = e.target.closest('.tab'); if(!t) return;
      document.querySelectorAll('#tabs .tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      state.side = t.dataset.side; save(); renderAll();
    });

    elFormat.addEventListener('change', (e)=>{
      state.format[state.currentDay][state.side] = e.target.value;
      const gs = desiredGroupSize(e.target.value);
      state.groups[state.currentDay][state.side] =
        state.groups[state.currentDay][state.side].map(g=>{
          const a = (Array.isArray(g)?g:[]).slice(0, gs);
          while (a.length < gs) a.push(null);
          return a;
        });
      // keep results in sync after format change
      initGroupsIfNeeded();
      save(); renderAll();
    });

    document.getElementById('btnClearSide').addEventListener('click', ()=>{
      const day = state.currentDay, side = state.side;
      if(confirm(`Clear all groups on ${day==='day1'?'Day 1':'Day 2'} ${side==='front'?'Front 9':'Back 9'}?`)){
        const gs = desiredGroupSize(state.format[day][side]);
        state.groups[day][side] = Array.from({length: state.numGroups}, ()=> Array(gs).fill(null));
        // clear results on this side
        const isTeam = window.TEAM_FORMATS.has(state.format[day][side]);
        state.results[day][side] = Array.from({length: state.numGroups}, ()=> isTeam ? null : [null,null]);
        save(); renderAll();
      }
    });

    /*********************************
     *  3) SUMMARY & VALIDATION
     *********************************/
    const elAlerts = document.getElementById('alerts');
    const elAssignTable = document.getElementById('assignmentTable');

    function renderAssignmentsTable(){
      sanitizeGroups();

      const used = {
        day1: { front:new Map(), back:new Map() },
        day2: { front:new Map(), back:new Map() },
      };
      const gf = a => Array.isArray(a) ? a : [];

      gf(state.groups.day1.front).forEach((g,i)=> gf(g).forEach(pid=>{ if(pid) used.day1.front.set(pid, i+1) }));
      gf(state.groups.day1.back ).forEach((g,i)=> gf(g).forEach(pid=>{ if(pid) used.day1.back .set(pid, i+1) }));
      gf(state.groups.day2.front).forEach((g,i)=> gf(g).forEach(pid=>{ if(pid) used.day2.front.set(pid, i+1) }));
      gf(state.groups.day2.back ).forEach((g,i)=> gf(g).forEach(pid=>{ if(pid) used.day2.back .set(pid, i+1) }));

      const rows = state.players.map(p=>{
        const tr = document.createElement('tr');
        tr.innerHTML =
          `<td>${playerDisplayName(p)}</td><td>${TEAM_LABELS[p.team]}</td>`+
          `<td>${(p.handicap!==null && p.handicap!==undefined) ? p.handicap : ''}</td>`+
          `<td>${used.day1.front.get(p.id)||''}</td>`+
          `<td>${used.day1.back.get(p.id)||''}</td>`+
          `<td>${used.day2.front.get(p.id)||''}</td>`+
          `<td>${used.day2.back.get(p.id)||''}</td>`;
        return tr;
      });
      elAssignTable.innerHTML = ''; rows.forEach(r=> elAssignTable.appendChild(r));

      const problems = [];

      ['day1','day2'].forEach(day=>{
        const label = day==='day1'?'Day 1':'Day 2';
        state.players.forEach(p=>{
          if(!used[day].front.has(p.id)) problems.push(`${label} Front: ${playerDisplayName(p)} not placed`);
          if(!used[day].back.has(p.id))  problems.push(`${label} Back: ${playerDisplayName(p)} not placed`);
        });
      });

      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const fmt = state.format[day][side];
          const isTeam = window.TEAM_FORMATS.has(fmt);
          gf(state.groups[day][side]).forEach((g,i)=>{
            const players = gf(g).filter(Boolean).map(findPlayer);
            if(isTeam){
              if(players.length>0){
                const oz = players.filter(p=>p.team==='ozark').length;
                const va = players.filter(p=>p.team==='valley').length;
                if(players.length !== 4) problems.push(`${printSide(day,side)} Group ${i+1}: incomplete (needs 4 players: 2v2)`);
                else if(!(oz===2 && va===2)) problems.push(`${printSide(day,side)} Group ${i+1}: must be 2 OZ + 2 VA (now ${oz}/${va})`);
              }
            }else{
              const pairIdx = [[0,1],[2,3]];
              pairIdx.forEach((pair, pi)=>{
                const ids = pair.map(pos => (Array.isArray(g)?g[pos]:null)).filter(Boolean);
                if (ids.length === 0) return;
                if (ids.length !== 2) {
                  problems.push(`${printSide(day,side)} Group ${i+1} Match ${pi+1}: needs exactly 2 players (1v1).`);
                  return;
                }
                const pA = findPlayer(ids[0]), pB = findPlayer(ids[1]);
                if (!pA || !pB || pA.team === pB.team) {
                  problems.push(`${printSide(day,side)} Group ${i+1} Match ${pi+1}: must be OZ vs VA.`);
                }
              });
            }
          });
        });
      });

      elAlerts.innerHTML = problems.length
        ? `<div class="card" style="border-color:#4d2626;background:#171112"><strong style="color:#ffb3b3">Needs attention</strong><ul style="margin:.3rem 0 .2rem .9rem">${problems.map(p=>`<li>${p}</li>`).join('')}</ul></div>`
        : `<div class="card" style="border-color:#244a3c;background:#0f1513"><strong style="color:#b9fbd2">Looks good</strong><div>Everyone is placed with correct pair sizes on both days.</div></div>`;
    }

    function printSide(day,side){
      return `${day==='day1'?'Day 1':'Day 2'} ${side==='front'?'Front 9':'Back 9'}`;
    }

    document.getElementById('pillOnce').addEventListener('click', ()=> alert('One placement per player per side per day is enforced when you drop a player again.'));
    document.getElementById('pillBalance').addEventListener('click', ()=> alert('Team events require 2v2 (2 Ozark + 2 Valley). Singles requires 1v1.'));

    /*********************************
     *  4) PRINT / EXPORT
     *********************************/
    const elPrintArea = document.getElementById('printArea');
    const elPrintContent = document.getElementById('printContent');

    elPrintArea.style.pointerEvents = 'none';

    document.getElementById('btnPrint').addEventListener('click', () => {
      ensurePrintOverrides();
      buildPrintPages();

      document.documentElement.setAttribute('data-printing', '1');
      elPrintArea.style.display = 'block';
      elPrintArea.style.pointerEvents = 'auto';

      const endOnce = (() => {
        let done = false;
        return () => {
          if (done) return;
          done = true;
          document.documentElement.removeAttribute('data-printing');
          elPrintArea.style.display = 'none';
          elPrintArea.style.pointerEvents = 'none';
          elPrintContent.innerHTML = '';
          window.removeEventListener('afterprint', endOnce);
          if (mm && mm.removeEventListener) mm.removeEventListener('change', onMM);
          if (mm && mm.removeListener) mm.removeListener(onMM);
          window.removeEventListener('focus', onFocus);
        };
      })();

      const onMM = (e) => { if (!e.matches) endOnce(); };
      const onFocus = () => { setTimeout(endOnce, 150); };

      window.addEventListener('afterprint', endOnce, { once: true });
      const mm = window.matchMedia && window.matchMedia('print');
      if (mm && mm.addEventListener) mm.addEventListener('change', onMM);
      else if (mm && mm.addListener) mm.addListener(onMM);
      window.addEventListener('focus', onFocus, { once: true });

      setTimeout(endOnce, 8000);

      window.print();
    });

    function ensurePrintOverrides(){
      if (document.getElementById('printOverridesScoped')) return;
      const style = document.createElement('style');
      style.id = 'printOverridesScoped';
      style.textContent = `
        @media print {
          html[data-printing="1"] .app { display:block !important; padding:0 !important; }
          html[data-printing="1"] header,
          html[data-printing="1"] .panel:not(.printable) { display:none !important; }
          html[data-printing="1"] .printable {
            display:block !important; width:100% !important; border:none !important;
            box-shadow:none !important; padding:0 !important; margin:0 !important; background:#fff !important;
          }
          html[data-printing="1"] body { background:#fff !important; color:#000 !important; }
        }
      `;
      document.head.appendChild(style);
    }

    function buildPrintPages(){
      const css = `
        <style>
          @page { size: Letter portrait; margin: 0.35in; }
          * { box-sizing: border-box; }
          body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }

          .page { page-break-after: always; width:100%; }
          .page:last-child { page-break-after: auto; }

          .title { margin:0 0 10px; font-size:22px; font-weight:800; }
          .day-header { font-size:16px; font-weight:700; margin:0 0 10px; }

          .sheet {
            border:1px solid #888; margin:10px 0 14px; padding:10px; border-radius:8px;
            page-break-inside: avoid; background:#fff; width:100%;
          }
          .sheet h2 { margin:0 0 8px 0; font-size:15px; }

          table.print { width:100%; border-collapse:collapse; table-layout:auto; font-size:12px; }
          .print th, .print td { border:1px solid #999; padding:7px 8px; vertical-align:top; overflow-wrap:anywhere; }
          .print th { text-align:left; background:#f5f5f5; font-weight:700; }

          .col-num { min-width:36px; text-align:center; }
          .col-format { min-width:110px; }
          .col-players { width:auto; }

          .muted { color:#555; }
          .match-line { margin:2px 0; }
          .vs { font-weight:700; padding:0 4px; }

          .side-wrap { page-break-inside: avoid; }
        </style>`;

      const mkNameTag = (pid) => {
        if (!pid) return '';
        const p = findPlayer(pid);
        if (!p) return '';
        const h = (p.handicap!==null && p.handicap!==undefined) ? `, HCP ${p.handicap}` : '';
        return `${playerDisplayName(p)} <span class="muted">(${p.team==='ozark'?'OZ':'VA'}${h})</span>`;
      };

      const sideBlock = (day, side) => {
        const fmt = state.format[day][side];
        const isTeam = window.TEAM_FORMATS.has(fmt);

        const rows = (state.groups[day][side] || []).map((g,i) => {
          if (isTeam) {
            const a = (g.slice(0,2)||[]).filter(Boolean).map(mkNameTag).join('<br/>') || '&nbsp;';
            const b = (g.slice(2,4)||[]).filter(Boolean).map(mkNameTag).join('<br/>') || '&nbsp;';
            return `
              <tr>
                <td class="col-num">${i+1}</td>
                <td class="col-format">${fmt}</td>
                <td class="col-players">
                  <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
                    <div style="border:1px solid #bbb;padding:6px;border-radius:6px"><strong>Team A</strong><br/>${a}</div>
                    <div style="border:1px solid #bbb;padding:6px;border-radius:6px"><strong>Team B</strong><br/>${b}</div>
                  </div>
                </td>
              </tr>`;
          } else {
            const a1 = mkNameTag(g[0]), b1 = mkNameTag(g[1]);
            const a2 = mkNameTag(g[2]), b2 = mkNameTag(g[3]);
            const line1 = (a1 || b1) ? `<div class="match-line">Match 1: ${a1 || '&nbsp;'} <span class="vs">vs</span> ${b1 || '&nbsp;'}</div>` : '';
            const line2 = (a2 || b2) ? `<div class="match-line">Match 2: ${a2 || '&nbsp;'} <span class="vs">vs</span> ${b2 || '&nbsp;'}</div>` : '';
            const names = (line1 + line2) || '&nbsp;';
            return `
              <tr>
                <td class="col-num">${i+1}</td>
                <td class="col-format">${fmt}</td>
                <td class="col-players">${names}</td>
              </tr>`;
          }
        }).join('');

        const sideLabel = side === 'front' ? 'Front 9' : 'Back 9';
        return `
          <div class="sheet side-wrap">
            <h2>${sideLabel} • ${fmt}</h2>
            <table class="print">
              <thead>
                <tr>
                  <th class="col-num">#</th>
                  <th class="col-format">Format</th>
                  <th class="col-players">Players</th>
                </tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>`;
      };

      const dayPage = (day) => {
        const date = state.dates[day] || '';
        const dayTitle = (day==='day1' ? 'Day 1' : 'Day 2') + (date ? ` • ${date}` : '');
        return `
          <div class="page">
            <div class="title">${state.eventName}</div>
            <div class="day-header">${dayTitle}</div>
            ${sideBlock(day, 'front')}
            ${sideBlock(day, 'back')}
          </div>`;
      };

      elPrintContent.innerHTML = css + dayPage('day1') + dayPage('day2');
    }

    /* ---- JSON export ---- */
    document.getElementById('btnExport').addEventListener('click', ()=>{
      const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'ozark_pairings_twodays.json';
      a.click();
    });

    /*********************************
     *  8) IMPORTS (CSV) — supports handicap
     *********************************/
    function pickFile(accept, multiple=false){
      return new Promise((resolve)=>{
        const inp = document.createElement('input');
        inp.type = 'file';
        inp.accept = accept;
        inp.multiple = !!multiple;
        inp.style.display = 'none';
        document.body.appendChild(inp);
        inp.addEventListener('change', ()=> resolve(Array.from(inp.files||[])));
        inp.click();
        setTimeout(()=> document.body.removeChild(inp), 0);
      });
    }

    function parseCSV(text){
      const rows = [];
      let row = [], field = '', inQuotes = false;
      for (let i=0;i<text.length;i++){
        const c = text[i];
        if (c === '"'){
          if (inQuotes && text[i+1] === '"'){ field += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (c === ',' && !inQuotes){
          row.push(field); field = '';
        } else if ((c === '\n' || c === '\r') && !inQuotes){
          if (field.length || row.length) { row.push(field); rows.push(row); row = []; field = ''; }
          if (c === '\r' && text[i+1] === '\n') i++;
        } else {
          field += c;
        }
      }
      if (field.length || row.length) { row.push(field); rows.push(row); }
      return rows;
    }

    function csvToObjects(csvText){
      const rows = parseCSV(csvText);
      if (!rows.length) return [];
      const header = rows[0].map(h => String(h||'').trim());
      const out = [];
      for (let i=1;i<rows.length;i++){
        const obj = {};
        const r = rows[i];
        header.forEach((h,idx)=> { obj[h] = r[idx] ?? ''; });
        out.push(obj);
      }
      return out;
    }

    document.getElementById('btnImportCSV').addEventListener('click', async ()=>{
      const files = await pickFile('.csv');
      if (!files.length) return;
      const file = files[0];
      const text = await file.text();

      let objs = csvToObjects(text);
      if (!objs.length) { alert('CSV appears empty.'); return; }

      const mapped = objs.map(o=>{
        const map = {};
        Object.keys(o).forEach(k => map[k.trim().toLowerCase()] = o[k]);
        const candidate = {
          id       : map.id || '',
          firstName: map.firstname || map.first || '',
          lastName : map.lastname  || map.last  || '',
          nickname : map.nickname  || map.nick  || '',
          team     : map.team      || '',
          email    : map.email     || '',
          phone    : map.phone     || '',
          name     : map.name      || '',
          handicap : map.handicap || map.hcp || map.hi || map.index || ''
        };
        return normalizePlayer(candidate);
      });

      state.players = mergePlayers(state.players || [], mapped);
      save(); renderAll();
      alert(`Imported ${mapped.length} rows from CSV and merged into the roster.`);
    });

    /*********************************
     *  Shuffle / Auto-balance / Reset
     *********************************/
    function randShuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function shuffleAll(){
      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const groups = state.groups?.[day]?.[side];
          if (!Array.isArray(groups) || !groups.length) return;

          const coords = [];
          const ids = [];
          groups.forEach((g, gi)=>{
            (Array.isArray(g)?g:[]).forEach((pid, pos)=>{
              if (pid) { coords.push({gi: gi, pos}); ids.push(pid); }
            });
          });

          if (ids.length < 2) return;

          const shuffled = randShuffle(ids);
          coords.forEach((c, i)=>{
            groups[c.gi][c.pos] = shuffled[i];
          });
        });
      });
      save();
      renderAll();
    }

    function autoBalanceAll(){
      const swapBetween = (arrA, arrB, condA, condB) => {
        for (let i=0;i<arrA.length;i++){
          for (let j=0;j<arrB.length;j++){
            const a = arrA[i], b = arrB[j];
            if (!a || !b) continue;
            if (condA(a) && condB(b)){
              [arrA[i], arrB[j]] = [b, a];
              return true;
            }
          }
        }
        return false;
      };

      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const fmt = state.format[day][side];
          const isTeam = window.TEAM_FORMATS.has(fmt);
          const groups = state.groups[day][side] || [];

          if (isTeam){
            const oz = pid => findPlayer(pid)?.team === 'ozark';
            const va = pid => findPlayer(pid)?.team === 'valley';

            for (let pass=0; pass<6; pass++){
              let changed = false;
              for (let g1=0; g1<groups.length; g1++){
                for (let g2=g1+1; g2<groups.length; g2++){
                  const A = groups[g1], B = groups[g2];
                  const ozA = A.filter(Boolean).filter(oz).length;
                  const vaA = A.filter(Boolean).filter(va).length;
                  const ozB = B.filter(Boolean).filter(oz).length;
                  const vaB = B.filter(Boolean).filter(va).length;

                  if (ozA > 2 && vaB > 2) changed = swapBetween(A, B, oz, va) || changed;
                  if (vaA > 2 && ozB > 2) changed = swapBetween(A, B, va, oz) || changed;
                }
              }
              if (!changed) break;
            }
          } else {
            groups.forEach(g=>{
              const pairs = [[0,1],[2,3]];
              pairs.forEach(([a,b])=>{
                const A = g[a], B = g[b];
                if (!A || !B) return;
                const tA = findPlayer(A)?.team, tB = findPlayer(B)?.team;
                if (tA && tB && tA === tB){
                  for (let gi=0; gi<groups.length; gi++){
                    const gg = groups[gi];
                    for (let k=0;k<gg.length;k++){
                      if (gg === g && (k===a || k===b)) continue;
                      const C = gg[k];
                      if (!C) continue;
                      const tC = findPlayer(C)?.team;
                      if (tC && tC !== tA){
                        [g[b], gg[k]] = [C, B];
                        return;
                      }
                    }
                  }
                }
              });
            });
          }
        });
      });
      save(); renderAll();
    }

    // Handicap-aware helpers + balancer
    const getHcp = (pid) => {
      const p = findPlayer(pid);
      return (p && Number.isFinite(p.handicap)) ? p.handicap : null;
    };
    function sumHcp(ids){
      let s = 0; (ids||[]).forEach(id=>{ const h = getHcp(id); if (h !== null) s += h; });
      return s;
    }
    function groupTeamDiff(g){
      const a = sumHcp([g[0], g[1]]);
      const b = sumHcp([g[2], g[3]]);
      return Math.abs(a - b);
    }
    function groupSinglesScore(g){
      const pairs = [[0,1],[2,3]];
      let score = 0;
      pairs.forEach(([i,j])=>{
        const hi = getHcp(g[i]); const hj = getHcp(g[j]);
        if (hi === null || hj === null) return;
        score += Math.abs(hi - hj);
      });
      return score;
    }

    function autoBalanceByHandicap(){
      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const fmt = state.format[day][side];
          const isTeam = window.TEAM_FORMATS.has(fmt);
          const groups = state.groups?.[day]?.[side] || [];
          if (!groups.length) return;

          for (let pass=0; pass<8; pass++){
            let improved = false;

            for (let g1 = 0; g1 < groups.length; g1++){
              for (let g2 = g1+1; g2 < groups.length; g2++){
                const A = groups[g1], B = groups[g2];
                if (!Array.isArray(A) || !Array.isArray(B)) continue;

                if (isTeam){
                  const base = groupTeamDiff(A) + groupTeamDiff(B);
                  for (let i=0; i<A.length; i++){
                    if (!A[i]) continue;
                    for (let j=0; j<B.length; j++){
                      if (!B[j]) continue;

                      [A[i], B[j]] = [B[j], A[i]]; // simulate

                      const okTeams = (() => {
                        const count = (g, t) => g.filter(Boolean).map(findPlayer).filter(p=>p && p.team===t).length;
                        const ozA = count(A,'ozark'), vaA = count(A,'valley');
                        const ozB = count(B,'ozark'), vaB = count(B,'valley');
                        return (ozA<=2 && vaA<=2 && ozB<=2 && vaB<=2);
                      })();

                      const score = okTeams ? (groupTeamDiff(A)+groupTeamDiff(B)) : Infinity;

                      if (score < base){ improved = true; }
                      else { [A[i], B[j]] = [B[j], A[i]]; } // undo
                    }
                  }
                } else {
                  const base = groupSinglesScore(A) + groupSinglesScore(B);

                  const pairSideOk = (g, idx) => {
                    const mate = (idx%2===0) ? idx+1 : idx-1;
                    const a = g[idx], b = g[mate];
                    if (!a || !b) return true;
                    const pa = findPlayer(a), pb = findPlayer(b);
                    return (pa && pb) ? (pa.team !== pb.team) : true;
                  };

                  for (let i=0; i<A.length; i++){
                    if (!A[i]) continue;
                    for (let j=0; j<B.length; j++){
                      if (!B[j]) continue;

                      [A[i], B[j]] = [B[j], A[i]]; // simulate
                      const okPairs = pairSideOk(A, i) && pairSideOk(B, j);
                      const score = okPairs ? (groupSinglesScore(A)+groupSinglesScore(B)) : Infinity;

                      if (score < base){ improved = true; }
                      else { [A[i], B[j]] = [B[j], A[i]]; } // undo
                    }
                  }
                }
              }
            }
            if (!improved) break;
          }
        });
      });

      save();
      renderAll();
    }

    // Buttons
    document.getElementById('btnShuffle').addEventListener('click', ()=>{
      if(!confirm('Shuffle all currently filled slots across Day 1 & Day 2? (Empty slots will stay empty.)')) return;
      shuffleAll();
    });

    document.getElementById('pillAutoBalance').addEventListener('click', ()=>{
      if(!confirm('Auto-balance teams across all groups (no handicaps)?')) return;
      autoBalanceAll();
    });

    document.getElementById('pillAutoHcp').addEventListener('click', ()=>{
      if(!confirm('Auto-balance by handicap across all groups (keeps OZ vs VA rules)?')) return;
      autoBalanceByHandicap();
    });

    document.getElementById('btnResetAll').addEventListener('click', ()=>{
      if(!confirm('Reset ALL players and pairings? This removes the entire roster and clears Day 1 & Day 2.')) return;

      state.players = [];

      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const gs = desiredGroupSize(state.format[day][side]);
          state.groups[day][side] = Array.from({length: state.numGroups}, ()=> Array(gs).fill(null));
        });
      });

      // wipe results too
      state.results = {
        day1: { 
          front: Array.from({length: state.numGroups}, ()=> window.TEAM_FORMATS.has(state.format.day1.front) ? null : [null,null]),
          back : Array.from({length: state.numGroups}, ()=> window.TEAM_FORMATS.has(state.format.day1.back ) ? null : [null,null]) 
        },
        day2: { 
          front: Array.from({length: state.numGroups}, ()=> window.TEAM_FORMATS.has(state.format.day2.front) ? null : [null,null]),
          back : Array.from({length: state.numGroups}, ()=> window.TEAM_FORMATS.has(state.format.day2.back ) ? null : [null,null]) 
        }
      };
      state.winAnnounced = null;

      save(); renderAll();

      if(confirm('Also clear the previous-site signups cache? (This is the "'+SIGNUPS_KEY+'" localStorage key.)')){
        try { localStorage.removeItem(SIGNUPS_KEY); } catch {}
        alert('Roster, pairings, and signups cache cleared.');
      } else {
        alert('Roster and pairings cleared.');
      }
    });

    /*********************************
     *  SCOREBOARD + RESULT CONTROLS
     *********************************/
    const TEAM_TO_LABEL = { ozark: TEAM_LABELS.ozark, valley: TEAM_LABELS.valley };
    const POINTS = { teamMatch: 1, singlesMatch: 1 };

    function buildResultControls(day, side, groupIndex, isTeam){
      const wrap = document.createElement('div');
      wrap.className = 'resultbar';

      if (isTeam){
        const label = document.createElement('span');
        label.className = 'rlabel';
        label.textContent = 'Result (Team):';
        wrap.appendChild(label);

        ['ozark','tie','valley'].forEach(key=>{
          const btn = document.createElement('button');
          btn.className = 'rbtn';
          btn.textContent = (key==='tie' ? 'Tie' : TEAM_TO_LABEL[key]);
          if (state.results[day][side][groupIndex] === key) btn.classList.add('active');
          btn.addEventListener('click', ()=>{
            state.results[day][side][groupIndex] = (state.results[day][side][groupIndex]===key ? null : key);
            save(); renderScoreboard(); renderGrid();
          });
          wrap.appendChild(btn);
        });

      } else {
        const mkRow = (matchIdx)=>{
          const row = document.createElement('div');
          row.className = 'resultbar';
          const lab = document.createElement('span');
          lab.className = 'rlabel';
          lab.textContent = `Match ${matchIdx+1}:`;
          row.appendChild(lab);

          ['ozark','tie','valley'].forEach(key=>{
            const btn = document.createElement('button');
            btn.className = 'rbtn';
            const cur = state.results[day][side][groupIndex] || [null,null];
            if (cur[matchIdx] === key) btn.classList.add('active');
            btn.textContent = (key==='tie' ? 'Tie' : TEAM_TO_LABEL[key]);
            btn.addEventListener('click', ()=>{
              const arr = state.results[day][side][groupIndex] || [null,null];
              arr[matchIdx] = (arr[matchIdx]===key ? null : key);
              state.results[day][side][groupIndex] = arr;
              save(); renderScoreboard(); renderGrid();
            });
            row.appendChild(btn);
          });

          return row;
        };

        const topSep = document.createElement('div');
        topSep.className = 'sep';
        wrap.appendChild(topSep);

        wrap.appendChild(mkRow(0));
        wrap.appendChild(mkRow(1));
      }

      return wrap;
    }

    function tallyPoints(){
      let oz = 0, va = 0;

      ['day1','day2'].forEach(day=>{
        ['front','back'].forEach(side=>{
          const fmt = state.format[day][side];
          const isTeam = window.TEAM_FORMATS.has(fmt);
          const rs = state.results?.[day]?.[side] || [];
          rs.forEach(r=>{
            if (isTeam){
              if (r === 'ozark') oz += POINTS.teamMatch;
              else if (r === 'valley') va += POINTS.teamMatch;
              else if (r === 'tie') { oz += POINTS.teamMatch/2; va += POINTS.teamMatch/2; }
            } else {
              const arr = Array.isArray(r) ? r : [null,null];
              arr.forEach(x=>{
                if (x === 'ozark') oz += POINTS.singlesMatch;
                else if (x === 'valley') va += POINTS.singlesMatch;
                else if (x === 'tie') { oz += POINTS.singlesMatch/2; va += POINTS.singlesMatch/2; }
              });
            }
          });
        });
      });

      return { ozark: oz, valley: va };
    }

    function renderScoreboard(){
      const s = tallyPoints();
      const elOz = document.getElementById('scoreOzark');
      const elVa = document.getElementById('scoreValley');
      if (elOz) elOz.textContent = (Math.round(s.ozark*10)/10).toString();
      if (elVa) elVa.textContent = (Math.round(s.valley*10)/10).toString();

      const badge = document.getElementById('winnerBadge');
      if (!badge) return;

      // Determine if someone has clinched (>= 15.5)
      const ozClinch = s.ozark >= WIN_THRESHOLD;
      const vaClinch = s.valley >= WIN_THRESHOLD;

      // If both exceed simultaneously, show leader (or tie if equal)
      let winner = null;
      if (ozClinch || vaClinch) {
        if (s.ozark > s.valley) winner = 'ozark';
        else if (s.valley > s.ozark) winner = 'valley';
        else winner = 'tie';
      }

      if (winner && winner !== 'tie') {
        badge.style.display = 'block';
        badge.textContent = `${TEAM_LABELS[winner]} has clinched at ${Math.max(s.ozark, s.valley)} points!`;
        if (state.winAnnounced !== winner) {
          alert(`${TEAM_LABELS[winner]} clinches the match at ${Math.max(s.ozark, s.valley)} points!`);
          state.winAnnounced = winner;
          save();
        }
      } else if (winner === 'tie') {
        badge.style.display = 'block';
        badge.textContent = `Tie at ${s.ozark}–${s.valley}. Continue until someone leads.`;
        if (state.winAnnounced !== null) { state.winAnnounced = null; save(); }
      } else {
        badge.style.display = 'none';
        if (state.winAnnounced !== null) { state.winAnnounced = null; save(); }
      }
    }

    /*********************************
     *  5) UI HYDRATE + RENDER ALL
     *********************************/
    function hydrateControls(){
      document.getElementById('eventName').value = state.eventName||'';
      document.getElementById('eventDate1').value = state.dates.day1||'';
      document.getElementById('eventDate2').value = state.dates.day2||'';
      document.getElementById('numGroups').value = state.numGroups||6;

      document.querySelectorAll('#dayTabs .tab').forEach(x=>{
        x.classList.toggle('active', x.dataset.day===state.currentDay);
      });
      document.querySelectorAll('#tabs .tab').forEach(x=>{
        x.classList.toggle('active', x.dataset.side===state.side);
      });

      elFormat.value = state.format[state.currentDay][state.side] || 'Best Ball';
    }

    function renderAll(){
      hydrateControls();
      renderTeamFilters();
      renderPlayers();
      renderGrid();
      renderAssignmentsTable();
      renderScoreboard();
    }

    /*********************************
     *  6) GLOBAL BRIDGE
     *********************************/
    window.state = state;
    window.save = save;
    window.renderAll = renderAll;
    window.TEAM_FORMATS = window.TEAM_FORMATS || new Set(['Best Ball','Scramble','Alt Shot','Shamble']);
    window.desiredGroupSize = window.desiredGroupSize || desiredGroupSize;

    /*********************************
     *  7) INIT / BOOT
     *********************************/
    try {
      load();
      ensurePlayers();
      sanitizeGroups();
      initGroupsIfNeeded();
      renderAll();
    } catch (e) {
      console.error('[boot] initial render failed:', e);
    }
  </script>

  <!-- Load autopair AFTER the inline script defines state/renderAll/save -->
  <script src="autopair.js"></script>
</body>
</html>
